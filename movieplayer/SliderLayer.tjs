// SliderLayer.tjs - slider layer
// Copyright (C)2001-2003, W.Dee ãƒ» free to modify and distribute

class SliderLayer extends Layer
{
	var Slider_min = 0; // minimum value
	var Slider_max = 0; // maximum value 
	var Slider_position = 0; // position
	var Slider_tabWidth = 10; // tab size
	var Slider_dragging = false; // whether it's being dragged
	var Slider_dragOriginX; // drag start x position
	var Slider_mouseOn = false; // whether the mouse is within the region
	var Slider_onChangeHandler = null; // handler called when the position is changed

	function SliderLayer(win, par)
	{
		super.Layer(win, par);

		focusable = true; // can get focus

		hitType = htMask;
		hitThreshold = 0;
	}

	function finalize()
	{
		super.finalize(...);
	}

	function assign(src)
	{
		// copy src information to this object
		Slider_min = src.Slider_min;
		Slider_max = src.Slider_max;
		Slider_position = src.Slider_position;
	}

	function onPaint()
	{
		// onPaint event
		// draw the contents of the layer
		super.onPaint(...);

		// prepare frequently used values in local variables
		var imw = imageWidth, imh = imageHeight;
		var tabw = Slider_tabWidth;
		var htabw = tabw >> 1;

		// apply underlay
		fillRect(0, 0, imw, imh, 0);

		if(focused)
		{
			// highlight with focus
			colorRect(0, 0, width-1, 1, clHighlight, 128);
			colorRect(0, 1, 1, height-2, clHighlight, 128);
			colorRect(0, height-1, width, 1, clHighlight, 128);
			colorRect(width-1, 0, 1, height-1, clHighlight, 128);
		}

		// center dent line
		{
			var himh = imh >> 1;
			var right = imw - tabw;
			fillRect(htabw, himh - 1, right, 1, 0x80000000);
			fillRect(htabw, himh    , right, 1, 0x80ffffff);
		}

		// tab
		var pos_x = int(
			(Slider_position-Slider_min) * (imw - tabw - 2)/(Slider_max - Slider_min)) +
			htabw + 1;
		var x_htabw = pos_x - htabw;
		fillRect(x_htabw, 0, tabw, imh, 0xffffff + (nodeEnabled ? 0 : 0xc0000000));
		if(Slider_mouseOn)
		{
			colorRect(x_htabw, 0, tabw, imh, clHighlight, 64);
		}
		colorRect(x_htabw + 1, 0, tabw-2, 1, 0xffffff, 128);
		colorRect(x_htabw + 1, imh - 1, tabw-2, 1, 0x000000, 128);
		colorRect(x_htabw, 0, 1, height, 0xffffff, 128);
		colorRect(pos_x + htabw - 1, 0, 1, height, 0x000000, 128);

	}

	function onKeyDown(key, shift, process)
	{
		// key pressed
		if(process)
		{
			if(key == VK_LEFT)
			{
				// left
				if(shift & ssAlt)
					position = Slider_position - 1;
				else
					position = Slider_position - int((Slider_max - Slider_min)/ (Slider_tabWidth-2) / 2);
				super.onKeyDown(key, shift, false); // pass false to process because it has been processed
			}
			else if(key == VK_RIGHT)
			{
				// right
				if(shift & ssAlt)
					position = Slider_position + 1;
				else
					position = Slider_position + int((Slider_max - Slider_min)/ (Slider_tabWidth-2) / 2);
				super.onKeyDown(key, shift, false); // pass false to process because it has been processed
			}
			else
			{
				super.onKeyDown(...);
			}
		}
		else
		{
			// do nothing if process is false
			super.onKeyDown(...);
		}
	}

	function onMouseDown(x, y, button)
	{
		// mouse button pressed
		focus();

		super.onMouseDown(...);

		var tabw = Slider_tabWidth;
		var htabw = tabw >> 1;
		var pos_x = int(
			(Slider_position-Slider_min) * (imageWidth - tabw - 2)/(Slider_max - Slider_min)) +
			htabw + 1;
		if(pos_x - htabw > x)
		{
			// left of tab
			position = Slider_position - int((Slider_max - Slider_min)/ (tabw-2));
		}
		else if(pos_x + htabw < x)
		{
			// right of tab
			position = Slider_position + int((Slider_max - Slider_min)/ (tabw-2));
		}
		else
		{
			// tab
			// start dragging the tab
			Slider_dragging = true;
			Slider_dragOriginX = x - pos_x;
		}
	}

	function onMouseUp(x, y, button)
	{
		// mouse button released
		super.onMouseUp(...);

		Slider_dragging = false;
	}

	function onMouseMove(x, y)
	{
		// mouse moved
		super.onMouseMove(...);

		if(Slider_dragging)
		{
			// drag tab
			position = int(
				(x - Slider_dragOriginX - (Slider_tabWidth >> 1)) * (Slider_max - Slider_min) /
				(imageWidth - Slider_tabWidth - 2) + Slider_min);
		}
	}

	function onMouseEnter()
	{
		// mouse has entered the layer area
		update();
		Slider_mouseOn = true;
		super.onMouseEnter(...);
	}

	function onMouseLeave()
	{
		// mouse has left the layer area
		update();
		Slider_mouseOn = false;
		Slider_dragging = false;
		super.onMouseLeave(...);
	}

	function onFocus()
	{
		// got focus
		super.onFocus(...);
		update();
	}

	function onBlur()
	{
		// lost focus
		super.onBlur(...);
		update();
	}

	function onNodeDisabled()
	{
		// layer node disabled
		super.onNodeDisabled(...);
		update();
	}

	function onNodeEnabled()
	{
		// layer node is enabled
		super.onNodeEnabled(...);
		update();
	}


	property width
	{
		setter(x)
		{
			super.width = x;
			imageWidth = x;
			update();
		}
		getter
		{
			return super.width;
		}
	}
	
	property height
	{
		setter(x)
		{
			super.height = x;
			imageHeight = x;
			update();
		}
		getter
		{
			return super.height;
		}
	}
	
	property max
	{
		setter(x)
		{
			Slider_max = x;
			update();
		}
		getter
		{
			return Slider_max;
		}
	}
	
	property min
	{
		setter(x)
		{
			Slider_min = x;
			update();
		}
		getter
		{
			return Slider_min;
		}
	}
	
	property position
	{
		setter(x)
		{
			if(x < Slider_min) x = Slider_min;
			if(x > Slider_max) x = Slider_max;
			Slider_position = x;
			update();
			onChange(Slider_position);
		}
		getter
		{
			return Slider_position;
		}
	}

	function setPos(x)
	{
		// set the current position but don't raise the event
		if(x < Slider_min) x = Slider_min;
		if(x > Slider_max) x = Slider_max;
		Slider_position = x;
		update();
	}

	property onChangeHandler
	{
		setter(x) { Slider_onChangeHandler = x; }
		getter    { return Slider_onChangeHandler; }
	}

	function onChange(pos)
	{
		// onChange
		window.action(%[target:this, type:'onChange', position:pos]);
		if(onChangeHandler !== null) onChangeHandler(this, pos);
	}
}
